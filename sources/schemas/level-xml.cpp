// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "level-xml.h"

namespace AT
{
  namespace XML
  {
    // VectorType
    // 

    const VectorType::XType& VectorType::
    x () const
    {
      return this->x_.get ();
    }

    VectorType::XType& VectorType::
    x ()
    {
      return this->x_.get ();
    }

    void VectorType::
    x (const XType& x)
    {
      this->x_.set (x);
    }

    const VectorType::YType& VectorType::
    y () const
    {
      return this->y_.get ();
    }

    VectorType::YType& VectorType::
    y ()
    {
      return this->y_.get ();
    }

    void VectorType::
    y (const YType& x)
    {
      this->y_.set (x);
    }


    // VelocityType
    // 

    const VelocityType::PositionType& VelocityType::
    position () const
    {
      return this->position_.get ();
    }

    VelocityType::PositionType& VelocityType::
    position ()
    {
      return this->position_.get ();
    }

    void VelocityType::
    position (const PositionType& x)
    {
      this->position_.set (x);
    }

    void VelocityType::
    position (::std::auto_ptr< PositionType > x)
    {
      this->position_.set (x);
    }

    const VelocityType::DirectionType& VelocityType::
    direction () const
    {
      return this->direction_.get ();
    }

    VelocityType::DirectionType& VelocityType::
    direction ()
    {
      return this->direction_.get ();
    }

    void VelocityType::
    direction (const DirectionType& x)
    {
      this->direction_.set (x);
    }

    const VelocityType::DirectionType& VelocityType::
    directionDefaultValue ()
    {
      return direction_default_value_;
    }

    const VelocityType::StrengthType& VelocityType::
    strength () const
    {
      return this->strength_.get ();
    }

    VelocityType::StrengthType& VelocityType::
    strength ()
    {
      return this->strength_.get ();
    }

    void VelocityType::
    strength (const StrengthType& x)
    {
      this->strength_.set (x);
    }

    const VelocityType::StrengthType& VelocityType::
    strengthDefaultValue ()
    {
      return strength_default_value_;
    }


    // RectangleType
    // 

    const RectangleType::XType& RectangleType::
    x () const
    {
      return this->x_.get ();
    }

    RectangleType::XType& RectangleType::
    x ()
    {
      return this->x_.get ();
    }

    void RectangleType::
    x (const XType& x)
    {
      this->x_.set (x);
    }

    const RectangleType::YType& RectangleType::
    y () const
    {
      return this->y_.get ();
    }

    RectangleType::YType& RectangleType::
    y ()
    {
      return this->y_.get ();
    }

    void RectangleType::
    y (const YType& x)
    {
      this->y_.set (x);
    }

    const RectangleType::WidthType& RectangleType::
    width () const
    {
      return this->width_.get ();
    }

    RectangleType::WidthType& RectangleType::
    width ()
    {
      return this->width_.get ();
    }

    void RectangleType::
    width (const WidthType& x)
    {
      this->width_.set (x);
    }

    const RectangleType::HeightType& RectangleType::
    height () const
    {
      return this->height_.get ();
    }

    RectangleType::HeightType& RectangleType::
    height ()
    {
      return this->height_.get ();
    }

    void RectangleType::
    height (const HeightType& x)
    {
      this->height_.set (x);
    }


    // LauncherType
    // 

    const LauncherType::InitialParticlesType& LauncherType::
    initialParticles () const
    {
      return this->initialParticles_.get ();
    }

    LauncherType::InitialParticlesType& LauncherType::
    initialParticles ()
    {
      return this->initialParticles_.get ();
    }

    void LauncherType::
    initialParticles (const InitialParticlesType& x)
    {
      this->initialParticles_.set (x);
    }

    const LauncherType::InitialParticlesType& LauncherType::
    initialParticlesDefaultValue ()
    {
      return initialParticles_default_value_;
    }

    const LauncherType::PositionType& LauncherType::
    position () const
    {
      return this->position_.get ();
    }

    LauncherType::PositionType& LauncherType::
    position ()
    {
      return this->position_.get ();
    }

    void LauncherType::
    position (const PositionType& x)
    {
      this->position_.set (x);
    }

    void LauncherType::
    position (::std::auto_ptr< PositionType > x)
    {
      this->position_.set (x);
    }

    const LauncherType::SpeedType& LauncherType::
    speed () const
    {
      return this->speed_.get ();
    }

    LauncherType::SpeedType& LauncherType::
    speed ()
    {
      return this->speed_.get ();
    }

    void LauncherType::
    speed (const SpeedType& x)
    {
      this->speed_.set (x);
    }

    const LauncherType::SpeedType& LauncherType::
    speedDefaultValue ()
    {
      return speed_default_value_;
    }

    const LauncherType::DirectionType& LauncherType::
    direction () const
    {
      return this->direction_.get ();
    }

    LauncherType::DirectionType& LauncherType::
    direction ()
    {
      return this->direction_.get ();
    }

    void LauncherType::
    direction (const DirectionType& x)
    {
      this->direction_.set (x);
    }

    const LauncherType::DirectionType& LauncherType::
    directionDefaultValue ()
    {
      return direction_default_value_;
    }

    const LauncherType::RadiusType& LauncherType::
    radius () const
    {
      return this->radius_.get ();
    }

    LauncherType::RadiusType& LauncherType::
    radius ()
    {
      return this->radius_.get ();
    }

    void LauncherType::
    radius (const RadiusType& x)
    {
      this->radius_.set (x);
    }

    const LauncherType::RadiusType& LauncherType::
    radiusDefaultValue ()
    {
      return radius_default_value_;
    }


    // LaunchersType
    // 

    const LaunchersType::LauncherSequence& LaunchersType::
    launcher () const
    {
      return this->launcher_;
    }

    LaunchersType::LauncherSequence& LaunchersType::
    launcher ()
    {
      return this->launcher_;
    }

    void LaunchersType::
    launcher (const LauncherSequence& s)
    {
      this->launcher_ = s;
    }


    // ReceiverType
    // 

    const ReceiverType::PositionType& ReceiverType::
    position () const
    {
      return this->position_.get ();
    }

    ReceiverType::PositionType& ReceiverType::
    position ()
    {
      return this->position_.get ();
    }

    void ReceiverType::
    position (const PositionType& x)
    {
      this->position_.set (x);
    }

    void ReceiverType::
    position (::std::auto_ptr< PositionType > x)
    {
      this->position_.set (x);
    }

    const ReceiverType::RadiusType& ReceiverType::
    radius () const
    {
      return this->radius_.get ();
    }

    ReceiverType::RadiusType& ReceiverType::
    radius ()
    {
      return this->radius_.get ();
    }

    void ReceiverType::
    radius (const RadiusType& x)
    {
      this->radius_.set (x);
    }

    const ReceiverType::RadiusType& ReceiverType::
    radiusDefaultValue ()
    {
      return radius_default_value_;
    }


    // WallsType
    // 

    const WallsType::WallSequence& WallsType::
    wall () const
    {
      return this->wall_;
    }

    WallsType::WallSequence& WallsType::
    wall ()
    {
      return this->wall_;
    }

    void WallsType::
    wall (const WallSequence& s)
    {
      this->wall_ = s;
    }


    // FlowType
    // 

    const FlowType::VelocitySequence& FlowType::
    velocity () const
    {
      return this->velocity_;
    }

    FlowType::VelocitySequence& FlowType::
    velocity ()
    {
      return this->velocity_;
    }

    void FlowType::
    velocity (const VelocitySequence& s)
    {
      this->velocity_ = s;
    }


    // LevelType
    // 

    const LevelType::MainLauncherType& LevelType::
    mainLauncher () const
    {
      return this->mainLauncher_.get ();
    }

    LevelType::MainLauncherType& LevelType::
    mainLauncher ()
    {
      return this->mainLauncher_.get ();
    }

    void LevelType::
    mainLauncher (const MainLauncherType& x)
    {
      this->mainLauncher_.set (x);
    }

    void LevelType::
    mainLauncher (::std::auto_ptr< MainLauncherType > x)
    {
      this->mainLauncher_.set (x);
    }

    const LevelType::OptionalLaunchersType& LevelType::
    optionalLaunchers () const
    {
      return this->optionalLaunchers_.get ();
    }

    LevelType::OptionalLaunchersType& LevelType::
    optionalLaunchers ()
    {
      return this->optionalLaunchers_.get ();
    }

    void LevelType::
    optionalLaunchers (const OptionalLaunchersType& x)
    {
      this->optionalLaunchers_.set (x);
    }

    void LevelType::
    optionalLaunchers (::std::auto_ptr< OptionalLaunchersType > x)
    {
      this->optionalLaunchers_.set (x);
    }

    const LevelType::ReceiverType& LevelType::
    receiver () const
    {
      return this->receiver_.get ();
    }

    LevelType::ReceiverType& LevelType::
    receiver ()
    {
      return this->receiver_.get ();
    }

    void LevelType::
    receiver (const ReceiverType& x)
    {
      this->receiver_.set (x);
    }

    void LevelType::
    receiver (::std::auto_ptr< ReceiverType > x)
    {
      this->receiver_.set (x);
    }

    const LevelType::WallsType& LevelType::
    walls () const
    {
      return this->walls_.get ();
    }

    LevelType::WallsType& LevelType::
    walls ()
    {
      return this->walls_.get ();
    }

    void LevelType::
    walls (const WallsType& x)
    {
      this->walls_.set (x);
    }

    void LevelType::
    walls (::std::auto_ptr< WallsType > x)
    {
      this->walls_.set (x);
    }

    const LevelType::FlowType& LevelType::
    flow () const
    {
      return this->flow_.get ();
    }

    LevelType::FlowType& LevelType::
    flow ()
    {
      return this->flow_.get ();
    }

    void LevelType::
    flow (const FlowType& x)
    {
      this->flow_.set (x);
    }

    void LevelType::
    flow (::std::auto_ptr< FlowType > x)
    {
      this->flow_.set (x);
    }

    const LevelType::RateType& LevelType::
    rate () const
    {
      return this->rate_.get ();
    }

    LevelType::RateType& LevelType::
    rate ()
    {
      return this->rate_.get ();
    }

    void LevelType::
    rate (const RateType& x)
    {
      this->rate_.set (x);
    }

    const LevelType::RateType& LevelType::
    rateDefaultValue ()
    {
      return rate_default_value_;
    }

    const LevelType::NextLevelOptional& LevelType::
    nextLevel () const
    {
      return this->nextLevel_;
    }

    LevelType::NextLevelOptional& LevelType::
    nextLevel ()
    {
      return this->nextLevel_;
    }

    void LevelType::
    nextLevel (const NextLevelType& x)
    {
      this->nextLevel_.set (x);
    }

    void LevelType::
    nextLevel (const NextLevelOptional& x)
    {
      this->nextLevel_ = x;
    }

    void LevelType::
    nextLevel (::std::auto_ptr< NextLevelType > x)
    {
      this->nextLevel_.set (x);
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace AT
{
  namespace XML
  {
    // VectorType
    //

    VectorType::
    VectorType (const XType& x,
                const YType& y)
    : ::xml_schema::Type (),
      x_ (x, ::xml_schema::Flags (), this),
      y_ (y, ::xml_schema::Flags (), this)
    {
    }

    VectorType::
    VectorType (const VectorType& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      x_ (x.x_, f, this),
      y_ (x.y_, f, this)
    {
    }

    VectorType::
    VectorType (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      x_ (f, this),
      y_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void VectorType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "x" && n.namespace_ ().empty ())
        {
          this->x_.set (XTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "y" && n.namespace_ ().empty ())
        {
          this->y_.set (YTraits::create (i, f, this));
          continue;
        }
      }

      if (!x_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "x",
          "");
      }

      if (!y_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "y",
          "");
      }
    }

    VectorType* VectorType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class VectorType (*this, f, c);
    }

    VectorType::
    ~VectorType ()
    {
    }

    // VelocityType
    //

    const VelocityType::DirectionType VelocityType::direction_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::Float, char >::create (
        ::std::string ("0"), 0, 0, 0));

    const VelocityType::StrengthType VelocityType::strength_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::Float, char >::create (
        ::std::string ("1"), 0, 0, 0));

    VelocityType::
    VelocityType (const PositionType& position,
                  const DirectionType& direction,
                  const StrengthType& strength)
    : ::xml_schema::Type (),
      position_ (position, ::xml_schema::Flags (), this),
      direction_ (direction, ::xml_schema::Flags (), this),
      strength_ (strength, ::xml_schema::Flags (), this)
    {
    }

    VelocityType::
    VelocityType (::std::auto_ptr< PositionType >& position,
                  const DirectionType& direction,
                  const StrengthType& strength)
    : ::xml_schema::Type (),
      position_ (position, ::xml_schema::Flags (), this),
      direction_ (direction, ::xml_schema::Flags (), this),
      strength_ (strength, ::xml_schema::Flags (), this)
    {
    }

    VelocityType::
    VelocityType (const VelocityType& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      position_ (x.position_, f, this),
      direction_ (x.direction_, f, this),
      strength_ (x.strength_, f, this)
    {
    }

    VelocityType::
    VelocityType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      position_ (f, this),
      direction_ (f, this),
      strength_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void VelocityType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // position
        //
        if (n.name () == "position" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< PositionType > r (
            PositionTraits::create (i, f, this));

          if (!position_.present ())
          {
            this->position_.set (r);
            continue;
          }
        }

        // direction
        //
        if (n.name () == "direction" && n.namespace_ ().empty ())
        {
          if (!direction_.present ())
          {
            this->direction_.set (DirectionTraits::create (i, f, this));
            continue;
          }
        }

        // strength
        //
        if (n.name () == "strength" && n.namespace_ ().empty ())
        {
          if (!strength_.present ())
          {
            this->strength_.set (StrengthTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!position_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "position",
          "");
      }

      if (!direction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "direction",
          "");
      }

      if (!strength_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "strength",
          "");
      }
    }

    VelocityType* VelocityType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class VelocityType (*this, f, c);
    }

    VelocityType::
    ~VelocityType ()
    {
    }

    // RectangleType
    //

    RectangleType::
    RectangleType (const XType& x,
                   const YType& y,
                   const WidthType& width,
                   const HeightType& height)
    : ::xml_schema::Type (),
      x_ (x, ::xml_schema::Flags (), this),
      y_ (y, ::xml_schema::Flags (), this),
      width_ (width, ::xml_schema::Flags (), this),
      height_ (height, ::xml_schema::Flags (), this)
    {
    }

    RectangleType::
    RectangleType (const RectangleType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      x_ (x.x_, f, this),
      y_ (x.y_, f, this),
      width_ (x.width_, f, this),
      height_ (x.height_, f, this)
    {
    }

    RectangleType::
    RectangleType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      x_ (f, this),
      y_ (f, this),
      width_ (f, this),
      height_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void RectangleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "x" && n.namespace_ ().empty ())
        {
          this->x_.set (XTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "y" && n.namespace_ ().empty ())
        {
          this->y_.set (YTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "width" && n.namespace_ ().empty ())
        {
          this->width_.set (WidthTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "height" && n.namespace_ ().empty ())
        {
          this->height_.set (HeightTraits::create (i, f, this));
          continue;
        }
      }

      if (!x_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "x",
          "");
      }

      if (!y_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "y",
          "");
      }

      if (!width_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "width",
          "");
      }

      if (!height_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "height",
          "");
      }
    }

    RectangleType* RectangleType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class RectangleType (*this, f, c);
    }

    RectangleType::
    ~RectangleType ()
    {
    }

    // LauncherType
    //

    const LauncherType::InitialParticlesType LauncherType::initialParticles_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::UnsignedShort, char >::create (
        ::std::string ("10"), 0, 0, 0));

    const LauncherType::SpeedType LauncherType::speed_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::Float, char >::create (
        ::std::string ("1"), 0, 0, 0));

    const LauncherType::DirectionType LauncherType::direction_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::Float, char >::create (
        ::std::string ("0"), 0, 0, 0));

    const LauncherType::RadiusType LauncherType::radius_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::UnsignedInt, char >::create (
        ::std::string ("60"), 0, 0, 0));

    LauncherType::
    LauncherType (const InitialParticlesType& initialParticles,
                  const PositionType& position,
                  const SpeedType& speed,
                  const DirectionType& direction,
                  const RadiusType& radius)
    : ::xml_schema::Type (),
      initialParticles_ (initialParticles, ::xml_schema::Flags (), this),
      position_ (position, ::xml_schema::Flags (), this),
      speed_ (speed, ::xml_schema::Flags (), this),
      direction_ (direction, ::xml_schema::Flags (), this),
      radius_ (radius, ::xml_schema::Flags (), this)
    {
    }

    LauncherType::
    LauncherType (const InitialParticlesType& initialParticles,
                  ::std::auto_ptr< PositionType >& position,
                  const SpeedType& speed,
                  const DirectionType& direction,
                  const RadiusType& radius)
    : ::xml_schema::Type (),
      initialParticles_ (initialParticles, ::xml_schema::Flags (), this),
      position_ (position, ::xml_schema::Flags (), this),
      speed_ (speed, ::xml_schema::Flags (), this),
      direction_ (direction, ::xml_schema::Flags (), this),
      radius_ (radius, ::xml_schema::Flags (), this)
    {
    }

    LauncherType::
    LauncherType (const LauncherType& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      initialParticles_ (x.initialParticles_, f, this),
      position_ (x.position_, f, this),
      speed_ (x.speed_, f, this),
      direction_ (x.direction_, f, this),
      radius_ (x.radius_, f, this)
    {
    }

    LauncherType::
    LauncherType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      initialParticles_ (f, this),
      position_ (f, this),
      speed_ (f, this),
      direction_ (f, this),
      radius_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LauncherType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // initialParticles
        //
        if (n.name () == "initialParticles" && n.namespace_ ().empty ())
        {
          if (!initialParticles_.present ())
          {
            this->initialParticles_.set (InitialParticlesTraits::create (i, f, this));
            continue;
          }
        }

        // position
        //
        if (n.name () == "position" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< PositionType > r (
            PositionTraits::create (i, f, this));

          if (!position_.present ())
          {
            this->position_.set (r);
            continue;
          }
        }

        // speed
        //
        if (n.name () == "speed" && n.namespace_ ().empty ())
        {
          if (!speed_.present ())
          {
            this->speed_.set (SpeedTraits::create (i, f, this));
            continue;
          }
        }

        // direction
        //
        if (n.name () == "direction" && n.namespace_ ().empty ())
        {
          if (!direction_.present ())
          {
            this->direction_.set (DirectionTraits::create (i, f, this));
            continue;
          }
        }

        // radius
        //
        if (n.name () == "radius" && n.namespace_ ().empty ())
        {
          if (!radius_.present ())
          {
            this->radius_.set (RadiusTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!initialParticles_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "initialParticles",
          "");
      }

      if (!position_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "position",
          "");
      }

      if (!speed_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "speed",
          "");
      }

      if (!direction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "direction",
          "");
      }

      if (!radius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "radius",
          "");
      }
    }

    LauncherType* LauncherType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class LauncherType (*this, f, c);
    }

    LauncherType::
    ~LauncherType ()
    {
    }

    // LaunchersType
    //

    LaunchersType::
    LaunchersType ()
    : ::xml_schema::Type (),
      launcher_ (::xml_schema::Flags (), this)
    {
    }

    LaunchersType::
    LaunchersType (const LaunchersType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      launcher_ (x.launcher_, f, this)
    {
    }

    LaunchersType::
    LaunchersType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      launcher_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LaunchersType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // launcher
        //
        if (n.name () == "launcher" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< LauncherType > r (
            LauncherTraits::create (i, f, this));

          this->launcher_.push_back (r);
          continue;
        }

        break;
      }
    }

    LaunchersType* LaunchersType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class LaunchersType (*this, f, c);
    }

    LaunchersType::
    ~LaunchersType ()
    {
    }

    // ReceiverType
    //

    const ReceiverType::RadiusType ReceiverType::radius_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::UnsignedInt, char >::create (
        ::std::string ("60"), 0, 0, 0));

    ReceiverType::
    ReceiverType (const PositionType& position,
                  const RadiusType& radius)
    : ::xml_schema::Type (),
      position_ (position, ::xml_schema::Flags (), this),
      radius_ (radius, ::xml_schema::Flags (), this)
    {
    }

    ReceiverType::
    ReceiverType (::std::auto_ptr< PositionType >& position,
                  const RadiusType& radius)
    : ::xml_schema::Type (),
      position_ (position, ::xml_schema::Flags (), this),
      radius_ (radius, ::xml_schema::Flags (), this)
    {
    }

    ReceiverType::
    ReceiverType (const ReceiverType& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      position_ (x.position_, f, this),
      radius_ (x.radius_, f, this)
    {
    }

    ReceiverType::
    ReceiverType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      position_ (f, this),
      radius_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ReceiverType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // position
        //
        if (n.name () == "position" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< PositionType > r (
            PositionTraits::create (i, f, this));

          if (!position_.present ())
          {
            this->position_.set (r);
            continue;
          }
        }

        // radius
        //
        if (n.name () == "radius" && n.namespace_ ().empty ())
        {
          if (!radius_.present ())
          {
            this->radius_.set (RadiusTraits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!position_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "position",
          "");
      }

      if (!radius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "radius",
          "");
      }
    }

    ReceiverType* ReceiverType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ReceiverType (*this, f, c);
    }

    ReceiverType::
    ~ReceiverType ()
    {
    }

    // WallsType
    //

    WallsType::
    WallsType ()
    : ::xml_schema::Type (),
      wall_ (::xml_schema::Flags (), this)
    {
    }

    WallsType::
    WallsType (const WallsType& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      wall_ (x.wall_, f, this)
    {
    }

    WallsType::
    WallsType (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      wall_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void WallsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // wall
        //
        if (n.name () == "wall" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< WallType > r (
            WallTraits::create (i, f, this));

          this->wall_.push_back (r);
          continue;
        }

        break;
      }
    }

    WallsType* WallsType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class WallsType (*this, f, c);
    }

    WallsType::
    ~WallsType ()
    {
    }

    // FlowType
    //

    FlowType::
    FlowType ()
    : ::xml_schema::Type (),
      velocity_ (::xml_schema::Flags (), this)
    {
    }

    FlowType::
    FlowType (const FlowType& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      velocity_ (x.velocity_, f, this)
    {
    }

    FlowType::
    FlowType (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      velocity_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void FlowType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // velocity
        //
        if (n.name () == "velocity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< VelocityType > r (
            VelocityTraits::create (i, f, this));

          this->velocity_.push_back (r);
          continue;
        }

        break;
      }
    }

    FlowType* FlowType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FlowType (*this, f, c);
    }

    FlowType::
    ~FlowType ()
    {
    }

    // LevelType
    //

    const LevelType::RateType LevelType::rate_default_value_ (
      ::xsd::cxx::tree::traits< ::xml_schema::Float, char >::create (
        ::std::string ("1"), 0, 0, 0));

    LevelType::
    LevelType (const MainLauncherType& mainLauncher,
               const OptionalLaunchersType& optionalLaunchers,
               const ReceiverType& receiver,
               const WallsType& walls,
               const FlowType& flow)
    : ::xml_schema::Type (),
      mainLauncher_ (mainLauncher, ::xml_schema::Flags (), this),
      optionalLaunchers_ (optionalLaunchers, ::xml_schema::Flags (), this),
      receiver_ (receiver, ::xml_schema::Flags (), this),
      walls_ (walls, ::xml_schema::Flags (), this),
      flow_ (flow, ::xml_schema::Flags (), this),
      rate_ (rateDefaultValue (), ::xml_schema::Flags (), this),
      nextLevel_ (::xml_schema::Flags (), this)
    {
    }

    LevelType::
    LevelType (::std::auto_ptr< MainLauncherType >& mainLauncher,
               ::std::auto_ptr< OptionalLaunchersType >& optionalLaunchers,
               ::std::auto_ptr< ReceiverType >& receiver,
               ::std::auto_ptr< WallsType >& walls,
               ::std::auto_ptr< FlowType >& flow)
    : ::xml_schema::Type (),
      mainLauncher_ (mainLauncher, ::xml_schema::Flags (), this),
      optionalLaunchers_ (optionalLaunchers, ::xml_schema::Flags (), this),
      receiver_ (receiver, ::xml_schema::Flags (), this),
      walls_ (walls, ::xml_schema::Flags (), this),
      flow_ (flow, ::xml_schema::Flags (), this),
      rate_ (rateDefaultValue (), ::xml_schema::Flags (), this),
      nextLevel_ (::xml_schema::Flags (), this)
    {
    }

    LevelType::
    LevelType (const LevelType& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      mainLauncher_ (x.mainLauncher_, f, this),
      optionalLaunchers_ (x.optionalLaunchers_, f, this),
      receiver_ (x.receiver_, f, this),
      walls_ (x.walls_, f, this),
      flow_ (x.flow_, f, this),
      rate_ (x.rate_, f, this),
      nextLevel_ (x.nextLevel_, f, this)
    {
    }

    LevelType::
    LevelType (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      mainLauncher_ (f, this),
      optionalLaunchers_ (f, this),
      receiver_ (f, this),
      walls_ (f, this),
      flow_ (f, this),
      rate_ (f, this),
      nextLevel_ (f, this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void LevelType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // mainLauncher
        //
        if (n.name () == "mainLauncher" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< MainLauncherType > r (
            MainLauncherTraits::create (i, f, this));

          if (!mainLauncher_.present ())
          {
            this->mainLauncher_.set (r);
            continue;
          }
        }

        // optionalLaunchers
        //
        if (n.name () == "optionalLaunchers" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< OptionalLaunchersType > r (
            OptionalLaunchersTraits::create (i, f, this));

          if (!optionalLaunchers_.present ())
          {
            this->optionalLaunchers_.set (r);
            continue;
          }
        }

        // receiver
        //
        if (n.name () == "receiver" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ReceiverType > r (
            ReceiverTraits::create (i, f, this));

          if (!receiver_.present ())
          {
            this->receiver_.set (r);
            continue;
          }
        }

        // walls
        //
        if (n.name () == "walls" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< WallsType > r (
            WallsTraits::create (i, f, this));

          if (!walls_.present ())
          {
            this->walls_.set (r);
            continue;
          }
        }

        // flow
        //
        if (n.name () == "flow" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< FlowType > r (
            FlowTraits::create (i, f, this));

          if (!flow_.present ())
          {
            this->flow_.set (r);
            continue;
          }
        }

        break;
      }

      if (!mainLauncher_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "mainLauncher",
          "");
      }

      if (!optionalLaunchers_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "optionalLaunchers",
          "");
      }

      if (!receiver_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "receiver",
          "");
      }

      if (!walls_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "walls",
          "");
      }

      if (!flow_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "flow",
          "");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "rate" && n.namespace_ ().empty ())
        {
          this->rate_.set (RateTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "nextLevel" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< NextLevelType > r (
            NextLevelTraits::create (i, f, this));

          this->nextLevel_.set (r);
          continue;
        }
      }

      if (!rate_.present ())
      {
        this->rate_.set (rateDefaultValue ());
      }
    }

    LevelType* LevelType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class LevelType (*this, f, c);
    }

    LevelType::
    ~LevelType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace AT
{
  namespace XML
  {
    ::std::auto_ptr< ::AT::XML::LevelType >
    level (const ::std::string& u,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::AT::XML::LevelType > r (
        ::AT::XML::level (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::AT::XML::LevelType >
    level (const ::std::string& u,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::AT::XML::LevelType > r (
        ::AT::XML::level (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::AT::XML::LevelType >
    level (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::AT::XML::LevelType > r (
        ::AT::XML::level (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::AT::XML::LevelType >
    level (::std::istream& is,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::AT::XML::level (isrc, f, p);
    }

    ::std::auto_ptr< ::AT::XML::LevelType >
    level (::std::istream& is,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::AT::XML::level (isrc, h, f, p);
    }

    ::std::auto_ptr< ::AT::XML::LevelType >
    level (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::AT::XML::level (isrc, h, f, p);
    }

    ::std::auto_ptr< ::AT::XML::LevelType >
    level (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::AT::XML::level (isrc, f, p);
    }

    ::std::auto_ptr< ::AT::XML::LevelType >
    level (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::AT::XML::level (isrc, h, f, p);
    }

    ::std::auto_ptr< ::AT::XML::LevelType >
    level (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::AT::XML::level (isrc, h, f, p);
    }

    ::std::auto_ptr< ::AT::XML::LevelType >
    level (::xercesc::InputSource& i,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::AT::XML::LevelType > r (
        ::AT::XML::level (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::AT::XML::LevelType >
    level (::xercesc::InputSource& i,
           ::xml_schema::ErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::AT::XML::LevelType > r (
        ::AT::XML::level (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::AT::XML::LevelType >
    level (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::AT::XML::LevelType > r (
        ::AT::XML::level (
          d, f | ::xml_schema::Flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::AT::XML::LevelType >
    level (const ::xercesc::DOMDocument& d,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::AT::XML::LevelType > r (
          ::AT::XML::level (
            c, f | ::xml_schema::Flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "level" &&
          n.namespace_ () == "http://speps.fr/attractouch/level")
      {
        ::std::auto_ptr< ::AT::XML::LevelType > r (
          ::xsd::cxx::tree::traits< ::AT::XML::LevelType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "level",
        "http://speps.fr/attractouch/level");
    }

    ::std::auto_ptr< ::AT::XML::LevelType >
    level (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::Flags f,
           const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "level" &&
          n.namespace_ () == "http://speps.fr/attractouch/level")
      {
        ::std::auto_ptr< ::AT::XML::LevelType > r (
          ::xsd::cxx::tree::traits< ::AT::XML::LevelType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "level",
        "http://speps.fr/attractouch/level");
    }
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace AT
{
  namespace XML
  {
    void
    operator<< (::xercesc::DOMElement& e, const VectorType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // x
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "x",
            e));

        a << i.x ();
      }

      // y
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "y",
            e));

        a << i.y ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const VelocityType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // position
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "position",
            e));

        s << i.position ();
      }

      // direction
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "direction",
            e));

        s << i.direction ();
      }

      // strength
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "strength",
            e));

        s << i.strength ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const RectangleType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // x
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "x",
            e));

        a << i.x ();
      }

      // y
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "y",
            e));

        a << i.y ();
      }

      // width
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "width",
            e));

        a << i.width ();
      }

      // height
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "height",
            e));

        a << i.height ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LauncherType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // initialParticles
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "initialParticles",
            e));

        s << i.initialParticles ();
      }

      // position
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "position",
            e));

        s << i.position ();
      }

      // speed
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "speed",
            e));

        s << i.speed ();
      }

      // direction
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "direction",
            e));

        s << i.direction ();
      }

      // radius
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "radius",
            e));

        s << i.radius ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LaunchersType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // launcher
      //
      for (LaunchersType::LauncherConstIterator
           b (i.launcher ().begin ()), n (i.launcher ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "launcher",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ReceiverType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // position
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "position",
            e));

        s << i.position ();
      }

      // radius
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "radius",
            e));

        s << i.radius ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const WallsType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // wall
      //
      for (WallsType::WallConstIterator
           b (i.wall ().begin ()), n (i.wall ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "wall",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FlowType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // velocity
      //
      for (FlowType::VelocityConstIterator
           b (i.velocity ().begin ()), n (i.velocity ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "velocity",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LevelType& i)
    {
      e << static_cast< const ::xml_schema::Type& > (i);

      // mainLauncher
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "mainLauncher",
            e));

        s << i.mainLauncher ();
      }

      // optionalLaunchers
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "optionalLaunchers",
            e));

        s << i.optionalLaunchers ();
      }

      // receiver
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "receiver",
            e));

        s << i.receiver ();
      }

      // walls
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "walls",
            e));

        s << i.walls ();
      }

      // flow
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "flow",
            e));

        s << i.flow ();
      }

      // rate
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "rate",
            e));

        a << i.rate ();
      }

      // nextLevel
      //
      if (i.nextLevel ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "nextLevel",
            e));

        a << *i.nextLevel ();
      }
    }

    void
    level (::std::ostream& o,
           const ::AT::XML::LevelType& s,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::AT::XML::level (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    level (::std::ostream& o,
           const ::AT::XML::LevelType& s,
           ::xml_schema::ErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::AT::XML::level (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    level (::std::ostream& o,
           const ::AT::XML::LevelType& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::AT::XML::level (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    level (::xercesc::XMLFormatTarget& t,
           const ::AT::XML::LevelType& s,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::AT::XML::level (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    level (::xercesc::XMLFormatTarget& t,
           const ::AT::XML::LevelType& s,
           ::xml_schema::ErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::AT::XML::level (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    level (::xercesc::XMLFormatTarget& t,
           const ::AT::XML::LevelType& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::NamespaceInfomap& m,
           const ::std::string& e,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::AT::XML::level (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    level (::xercesc::DOMDocument& d,
           const ::AT::XML::LevelType& s,
           ::xml_schema::Flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "level" &&
          n.namespace_ () == "http://speps.fr/attractouch/level")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "level",
          "http://speps.fr/attractouch/level");
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    level (const ::AT::XML::LevelType& s,
           const ::xml_schema::NamespaceInfomap& m,
           ::xml_schema::Flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "level",
          "http://speps.fr/attractouch/level",
          m, f));

      ::AT::XML::level (*d, s, f);
      return d;
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

